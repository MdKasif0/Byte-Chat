rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    match /phonenumbers/{phoneNumber} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.uid;
      allow delete: if isSignedIn() && request.auth.uid == resource.data.uid;
    }

    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId;
    }

    match /chats/{chatId} {
      // Allow a list query only if it's explicitly filtering for chats the user is a member of.
      allow list: if isSignedIn() && request.query.where.find(
        w => w[0] == 'members' && w[1] == 'array-contains' && w[2] == request.auth.uid
      ) != null;

      // Allow reading a single chat document.
      // For 1-on-1 chats, we check if the user's ID is part of the document ID. This works even if the doc doesn't exist yet.
      // For group chats, we check if the user is in the members list of the existing document.
      allow get: if isSignedIn() && (
        (request.auth.uid in chatId.split('_')) || 
        (resource.data.isGroup == true && request.auth.uid in resource.data.members)
      );

      // Allow creating a chat document.
      allow create: if isSignedIn() && (
        // Rule for 1-on-1 chats
        (request.resource.data.isGroup == false &&
         request.auth.uid in request.resource.data.members &&
         chatId == request.resource.data.members.sort().join('_')) ||
        // Rule for group chats
        (request.resource.data.isGroup == true &&
         request.auth.uid == request.resource.data.createdBy)
      );

      // Allow updating a chat if the user is a member.
      allow update: if isSignedIn() && resource.data.members.includes(request.auth.uid);

      match /messages/{messageId} {
        // The get() call here is permitted by the parent `allow get` rule.
        allow read, create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.members.includes(request.auth.uid);
        allow update: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.members.includes(request.auth.uid);
        allow delete: if isSignedIn() 
                      && get(/databases/$(database)/documents/chats/$(chatId)).data.members.includes(request.auth.uid)
                      && resource.data.senderId == request.auth.uid;
      }
    }
    
    match /calls/{callId} {
      allow create: if isSignedIn() && get(/databases/$(database)/documents/chats/$(request.resource.data.chatId)).data.members.includes(request.auth.uid);
      allow read, update: if isSignedIn() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.calleeId);
      match /{candidateCollection}/{candidateId} {
        allow create: if isSignedIn() && (request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.callerId || request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.calleeId);
      }
    }

    match /feedback/{feedbackId} {
      allow create: if isSignedIn();
    }
  }
}
