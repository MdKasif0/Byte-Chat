rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthed() {
      return request.auth != null;
    }

    match /users/{userId} {
      allow get, list: if isAuthed();
      allow create: if isAuthed() && request.auth.uid == userId;
      allow update: if isAuthed() && request.auth.uid == userId;
    }

    match /phonenumbers/{phoneNumber} {
      allow get: if isAuthed();
      allow create: if isAuthed() && request.resource.data.uid == request.auth.uid;
      allow delete: if isAuthed() && resource.data.uid == request.auth.uid;
    }

    match /feedback/{feedbackId} {
      allow create: if isAuthed() && request.resource.data.userId == request.auth.uid;
      allow read, update, delete: if false;
    }

    match /chats/{chatId} {
      // This is the key rule to fix the "failed to create chat" error.
      // It allows a read (get) on a chat document under two conditions:
      // 1. If the document exists, the user must be a member.
      // 2. If the document does NOT exist (which happens when checking before creating a 1-on-1 chat),
      //    it allows the check if the user's ID is part of the document ID itself (e.g., 'uid1_uid2').
      allow get: if isAuthed() && (
        (exists(/databases/$(database)/documents/chats/$(chatId)) && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.members) ||
        (!exists(/databases/$(database)/documents/chats/$(chatId)) && request.auth.uid in chatId.split('_'))
      );

      allow list: if isAuthed() && request.query.where.field == "members" && request.query.where.op == "array-contains";

      allow create: if isAuthed() && request.auth.uid in request.resource.data.members;

      allow update: if isAuthed() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.members;

      match /messages/{messageId} {
        function isChatMember() {
          return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.members;
        }

        allow list, get: if isAuthed() && isChatMember();
        
        allow create: if isAuthed() && 
                      request.resource.data.senderId == request.auth.uid &&
                      isChatMember();
                      
        allow delete: if isAuthed() && 
                      resource.data.senderId == request.auth.uid &&
                      isChatMember();
                      
        allow update: if isAuthed() &&
                      isChatMember() &&
                      (request.resource.data.content == resource.data.content || resource.data.senderId == request.auth.uid);
      }
    }

    match /calls/{callId} {
        allow get: if isAuthed() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.calleeId);

        allow create: if isAuthed() && request.resource.data.callerId == request.auth.uid;

        allow update: if isAuthed() && (
            (request.auth.uid == resource.data.callerId && request.resource.data.status in ['cancelled', 'ended']) ||
            (request.auth.uid == resource.data.calleeId && request.resource.data.status in ['connected', 'rejected', 'ended'])
        );
        
        match /{candidateCollection}/{candidateId} {
            function isCallerOfParent() {
              return request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.callerId;
            }
            function isCalleeOfParent() {
                return request.auth.uid == get(/databases/$(database)/documents/calls/$(callId)).data.calleeId;
            }

            allow get: if isAuthed() && (isCallerOfParent() || isCalleeOfParent());

            allow create: if isAuthed() && (
                (candidateCollection == 'callerCandidates' && isCallerOfParent()) ||
                (candidateCollection == 'calleeCandidates' && isCalleeOfParent())
            );
        }
    }
  }
}
